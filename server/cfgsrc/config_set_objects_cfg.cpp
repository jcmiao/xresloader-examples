
// Copyright 2021 xresloader. All rights reserved.
// Generated by xres-code-generator, please don't edit it
//

#include <algorithm>
#include <cstddef>
#include <cstdio>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <tuple>
#include <vector>
#include <sstream>

// 禁用掉unordered_map，我们要保证mt_core中逻辑有序
#if 0 && defined(__cplusplus) && __cplusplus >= 201103L
#include <unordered_map>
#define LIBXRESLOADER_USING_HASH_MAP 1
#else

#endif


#if defined(_MSC_VER)
#pragma warning(push)
#if ((defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L))
#pragma warning(disable : 4996)
#pragma warning(disable : 4309)
#endif
#if _MSC_VER >= 1922 && ((defined(__cplusplus) && __cplusplus >= 201704L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201704L))
#pragma warning(disable : 5054)
#endif
#if _MSC_VER < 1910
#pragma warning(disable : 4800)
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <Windows.h>
#endif

#ifdef max
#undef max
#endif

#ifdef min
#undef min
#endif

#if defined(__GNUC__) && !defined(__clang__) && !defined(__apple_build_version__)
#if (__GNUC__ * 100 + __GNUC_MINOR__ * 10) >= 460
#pragma GCC diagnostic push
#endif
#pragma GCC diagnostic ignored "-Wunused-parameter"
#elif defined(__clang__) || defined(__apple_build_version__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/stubs/common.h>

#if defined(__GNUC__) && !defined(__clang__) && !defined(__apple_build_version__)
#if (__GNUC__ * 100 + __GNUC_MINOR__ * 10) >= 460
#pragma GCC diagnostic pop
#endif
#elif defined(__clang__) || defined(__apple_build_version__)
#pragma clang diagnostic pop
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#include "config_manager.h"
#include "config_set_objects_cfg.h"

#ifndef UTIL_STRFUNC_SNPRINTF
// @see https://github.com/atframework/atframe_utils/blob/master/include/common/string_oprs.h

#if (defined(_MSC_VER) && _MSC_VER >= 1600) || (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || defined(__STDC_LIB_EXT1__)
#ifdef _MSC_VER
#define UTIL_STRFUNC_SNPRINTF(...) sprintf_s(__VA_ARGS__)
#else
#define UTIL_STRFUNC_SNPRINTF(...) snprintf_s(__VA_ARGS__)
#endif

#define UTIL_STRFUNC_C11_SUPPORT 1
#else
#define UTIL_STRFUNC_SNPRINTF(...) snprintf(__VA_ARGS__)
#endif
#endif

namespace excel {


    namespace details {
        template <typename TCH>
        static inline bool is_space(const TCH &c) {
            return ' ' == c || '\t' == c || '\r' == c || '\n' == c;
        }

        template <typename TCH>
        static std::pair<const TCH *, size_t> trim(const TCH *str_begin, size_t sz) {
            if (0 == sz) {
                const TCH *str_end = str_begin;
                while (str_end && *str_end) {
                    ++str_end;
                }

                sz = str_end - str_begin;
            }

            if (str_begin) {
                while (*str_begin && sz > 0) {
                    if (!is_space(*str_begin)) {
                        break;
                    }

                    --sz;
                    ++str_begin;
                }
            }

            size_t sub_str_sz = sz;
            if (str_begin) {
                while (sub_str_sz > 0) {
                    if (is_space(str_begin[sub_str_sz - 1])) {
                        --sub_str_sz;
                    } else {
                        break;
                    }
                }
            }

            return std::make_pair(str_begin, sub_str_sz);
        }
    }

    config_set_objects_cfg::config_set_objects_cfg() {
    }

    config_set_objects_cfg::~config_set_objects_cfg(){
    }

    int config_set_objects_cfg::on_inited() {
        ::excel::lock::write_lock_holder<::excel::lock::spin_rw_lock> wlh(load_file_lock_);
        
        file_status_.clear();
        datasource_.clear();
        return reload_file_lists();
    }

    int config_set_objects_cfg::load_all() {
        int ret = 0;
        ::excel::lock::write_lock_holder<::excel::lock::spin_rw_lock> wlh(load_file_lock_);
        for (std::unordered_map<std::string, bool>::iterator iter = file_status_.begin(); iter != file_status_.end(); ++ iter) {
            if (!iter->second) {
                int res = load_file(iter->first);
                if (res < 0) {
                    EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load config file %s for %s failed", iter->first.c_str(), "config_set_objects_cfg");
                    ret = res;
                } else if (ret >= 0) {
                    ret += res;
                }
            }
        }

        return ret;
    }

    void config_set_objects_cfg::clear() {
        ::excel::lock::write_lock_holder<::excel::lock::spin_rw_lock> wlh(load_file_lock_);
        id_data_.clear();
        type_data_.clear();
        file_status_.clear();
        datasource_.clear();
        reload_file_lists();
    }

    const std::list<org::xresloader::pb::xresloader_data_source>& config_set_objects_cfg::get_data_source() const {
        return datasource_;
    }

    int config_set_objects_cfg::load_file(const std::string& file_path) {
        std::unordered_map<std::string, bool>::iterator iter = file_status_.find(file_path);
        if (iter == file_status_.end()) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load config file %s for %s failed, not exist in any file_list/file_path", file_path.c_str(), "config_set_objects_cfg");
            return -2;
        }

        if (iter->second) {
            return 0;
        }
        iter->second = true;

        std::string content;
        if (!config_manager::me()->load_file_data(content, file_path)) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load file %s for %s failed", file_path.c_str(), "config_set_objects_cfg");
            return -3;
        }

        ::org::xresloader::pb::xresloader_datablocks outer_data;
        if (!outer_data.ParseFromString(content)) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] parse file %s for %s(message type: %s) failed: %s",
                file_path.c_str(), "config_set_objects_cfg", "::org::xresloader::pb::xresloader_datablocks",
                outer_data.InitializationErrorString().c_str()
            );
            return -4;
        }

        if (!config_manager::me()->filter<item_type>(outer_data, file_path)) {
            return -5;
        }

        datasource_.clear();
        for (int i = 0; i < outer_data.header().data_source_size(); ++ i) {
            datasource_.push_back(outer_data.header().data_source(i));
        }

        // vector index: type
        if(type_data_.capacity() < static_cast<size_t>(outer_data.data_block_size())) {
            type_data_.reserve(static_cast<size_t>(outer_data.data_block_size()));
        }

        for (int i = 0; i < outer_data.data_block_size(); ++ i) {
            std::shared_ptr<item_type> new_item = std::make_shared<item_type>();
            if (!new_item) {
                EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] parse file %s for %s(message type: %s) and create item object %d failed",
                    file_path.c_str(), "config_set_objects_cfg", "::org::xresloader::pb::xresloader_datablocks", i
                );
                return -5;
            }

            if (!std::const_pointer_cast<proto_type>(new_item)->ParseFromString(outer_data.data_block(i))) {
                EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] parse message %d in %s for %s(message type: %s) failed: %s",
                    i, file_path.c_str(), "config_set_objects_cfg", "::org::xresloader::pb::xresloader_datablocks",
                    new_item->InitializationErrorString().c_str()
                );
                return -6;
            }
            merge_data(new_item);
        }

        EXCEL_CONFIG_MANAGER_LOGINFO("[EXCEL] load file %s for %s(message type: %s) with %d item(s) success",
            file_path.c_str(), "config_set_objects_cfg", "::org::xresloader::pb::xresloader_datablocks",
            outer_data.data_block_size()
        );

        return 1;
    }

    int config_set_objects_cfg::load_list(const char* file_list_path) {
        std::string content;
        if (!config_manager::me()->load_file_data(content, file_list_path)) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load file %s for %s failed", file_list_path, "config_set_objects_cfg");
            return -1;
        }

        const char* line_start = content.c_str();
        const char* line_end;
        int ret = 0;
        for (; line_start < content.c_str() + content.size() && *line_start; line_start = line_end + 1) {
            line_end = line_start;

            while (*line_end && '\r' != *line_end && '\n' != *line_end) {
                ++ line_end;
            }

            std::pair<const char*, size_t> file_path_trimed = details::trim(line_start, line_end - line_start);
            if (file_path_trimed.second == 0) {
                continue;
            }

            std::string file_path;
            file_path.assign(file_path_trimed.first, file_path_trimed.second);
            if (file_status_.end() == file_status_.find(file_path)) {
                file_status_[file_path] = false;
            }
        }

        return ret;
    }

    int config_set_objects_cfg::reload_file_lists() {
        file_status_["../config/sample-data/objects_cfg.bin"] = false;
        return 0;
    }

    void config_set_objects_cfg::merge_data(item_ptr_type item) {
        if (!item) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] merge_data(nullptr) is not allowed for %s", "config_set_objects_cfg");
            return;
        }

        // index: id
        do {
            std::tuple<uint32_t> key = std::make_tuple(item->id());
            if (id_data_.end() != id_data_.find(key)) {
                EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] merge_data() with key=<%u> for %s is already exists, we will cover it with the newer value", 
                    static_cast<unsigned int>(item->id()), "config_set_objects_cfg");
            }
            id_data_[key] = item;
        } while(false);

        // index: type
        do {
            size_t idx = 0;
            idx = static_cast<size_t>(item->type());
            if (type_data_.capacity() <= idx) {
                type_data_.reserve(idx * 2 + 1);
            }

            if (type_data_.size() <= idx) {
                type_data_.resize(idx + 1);
            }

            type_data_[idx].push_back(item);
        } while(false);

    }

// ------------------- index: id APIs -------------------
    config_set_objects_cfg::id_value_type config_set_objects_cfg::get_by_id(uint32_t Id) {
        ::excel::lock::read_lock_holder<::excel::lock::spin_rw_lock> rlh(load_file_lock_);
        id_container_type::iterator iter = id_data_.find(std::make_tuple(Id));
        if (iter != id_data_.end()) {
            return iter->second;
        }

        std::string file_path = "../config/sample-data/objects_cfg.bin";

        int res = load_file(file_path);
        if (res < 0) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load file %s for %s failed, res: %d", file_path.c_str(), "config_set_objects_cfg", res);
            return nullptr;
        }

        iter = id_data_.find(std::make_tuple(Id));
        if (iter == id_data_.end()) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load index %s with key=<%u> for %s failed, not found",
                "id", static_cast<unsigned int>(Id), "config_set_objects_cfg"
            );
            if (config_manager::me()->get_on_not_found()) {
                config_manager::on_not_found_event_data_t evt_data;
                evt_data.data_source = &datasource_;
                evt_data.message_descriptor = ::objects_cfg::descriptor();

                char keys_buffer[4096];
                int n = UTIL_STRFUNC_SNPRINTF(keys_buffer, sizeof(keys_buffer) - 1, "%u", static_cast<unsigned int>(Id));
                evt_data.index_name = "id";
                if (n < static_cast<int>(sizeof(keys_buffer)) && n >= 0) {
                    keys_buffer[n] = 0;
                } else {
                    keys_buffer[sizeof(keys_buffer) - 1] = 0;
                }
                evt_data.keys = keys_buffer;
                evt_data.is_list = false;
                evt_data.list_index = 0;
                config_manager::me()->get_on_not_found()(evt_data);
            }
            return nullptr;
        }

        return iter->second;
    }

    const config_set_objects_cfg::id_container_type& config_set_objects_cfg::get_all_of_id() const {
        return id_data_;
    }
// ------------------- index: type APIs -------------------
    const config_set_objects_cfg::type_value_type* config_set_objects_cfg::get_list_by_type(uint32_t Type) {
        ::excel::lock::read_lock_holder<::excel::lock::spin_rw_lock> rlh(load_file_lock_);
        return _get_list_by_type(Type);
    }

    config_set_objects_cfg::item_ptr_type config_set_objects_cfg::get_by_type(uint32_t Type, size_t index) {
        ::excel::lock::read_lock_holder<::excel::lock::spin_rw_lock> rlh(load_file_lock_);
        const config_set_objects_cfg::type_value_type* list_item = _get_list_by_type(Type);
        if (nullptr == list_item) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load index %s with key=<%u>, index=%llu for %s failed, list not found",
                "type", static_cast<unsigned int>(Type), 
                static_cast<unsigned long long>(index), "config_set_objects_cfg"
            );
            if (config_manager::me()->get_on_not_found()) {
                config_manager::on_not_found_event_data_t evt_data;
                evt_data.data_source = &datasource_;
                evt_data.message_descriptor = ::objects_cfg::descriptor();

                char keys_buffer[4096];
                int n = UTIL_STRFUNC_SNPRINTF(keys_buffer, sizeof(keys_buffer) - 1, "%u", static_cast<unsigned int>(Type));
                evt_data.index_name = "type";
                if (n < static_cast<int>(sizeof(keys_buffer)) && n >= 0) {
                    keys_buffer[n] = 0;
                } else {
                    keys_buffer[sizeof(keys_buffer) - 1] = 0;
                }
                evt_data.keys = keys_buffer;
                evt_data.is_list = true;
                evt_data.list_index = index;
                config_manager::me()->get_on_not_found()(evt_data);
            }
            return nullptr;
        }

        if (list_item->size() <= index) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load index %s with key=<%u>, index=%llu for %s failed, index entend %llu",
                "type", static_cast<unsigned int>(Type), 
                static_cast<unsigned long long>(index), "config_set_objects_cfg", static_cast<unsigned long long>(list_item->size())
            );
            if (config_manager::me()->get_on_not_found()) {
                config_manager::on_not_found_event_data_t evt_data;
                evt_data.data_source = &datasource_;
                evt_data.message_descriptor = ::objects_cfg::descriptor();

                char keys_buffer[4096];
                int n = UTIL_STRFUNC_SNPRINTF(keys_buffer, sizeof(keys_buffer) - 1, "%u", static_cast<unsigned int>(Type));
                evt_data.index_name = "type";
                if (n < static_cast<int>(sizeof(keys_buffer)) && n >= 0) {
                    keys_buffer[n] = 0;
                } else {
                    keys_buffer[sizeof(keys_buffer) - 1] = 0;
                }
                evt_data.keys = keys_buffer;
                evt_data.is_list = true;
                evt_data.list_index = index;
                config_manager::me()->get_on_not_found()(evt_data);
            }
            return nullptr;
        }

        return (*list_item)[index];
    }

    const config_set_objects_cfg::type_value_type* config_set_objects_cfg::_get_list_by_type(uint32_t Type) {
        size_t idx = 0;
        idx = static_cast<size_t>(Type);
        //if (type_data_.size() > idx && type_data_[idx]) {
        if (type_data_.size() > idx) {
            return &type_data_[idx];
        }

        std::string file_path = "../config/sample-data/objects_cfg.bin";

        int res = load_file(file_path);
        if (res < 0) {
            EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load file %s for %s failed, res: %d", file_path.c_str(), "config_set_objects_cfg", res);
            return nullptr;
        }

        // if (type_data_.size() > idx && type_data_[idx]) {
        if (type_data_.size() > idx) {
            return &type_data_[idx];
        }

        EXCEL_CONFIG_MANAGER_LOGERROR("[EXCEL] load index %s with key=<%u> for %s failed, not found",
            "type", static_cast<unsigned int>(Type), "config_set_objects_cfg"
        );
        if (config_manager::me()->get_on_not_found()) {
            config_manager::on_not_found_event_data_t evt_data;
            evt_data.data_source = &datasource_;
            evt_data.message_descriptor = ::objects_cfg::descriptor();

            char keys_buffer[4096];
            int n = UTIL_STRFUNC_SNPRINTF(keys_buffer, sizeof(keys_buffer) - 1, "%u", static_cast<unsigned int>(Type));
            evt_data.index_name = "type";
            if (n < static_cast<int>(sizeof(keys_buffer)) && n >= 0) {
                keys_buffer[n] = 0;
            } else {
                keys_buffer[sizeof(keys_buffer) - 1] = 0;
            }
            evt_data.keys = keys_buffer;
            evt_data.is_list = true;
            evt_data.list_index = 0;
            config_manager::me()->get_on_not_found()(evt_data);
        }
        return nullptr;

    }


    const config_set_objects_cfg::type_container_type& config_set_objects_cfg::get_all_of_type() const {
        return type_data_;
    }


} // excel
